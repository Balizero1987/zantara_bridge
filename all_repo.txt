===== src/chatRouter.ts =====
import { Router } from "express";
import calendar from "./api/calendar";
const router = Router();
router.use(calendar);
export default router;
===== src/middleware/rateLimit.ts =====
import { Request, Response, NextFunction } from 'express';

type Bucket = { count: number; resetAt: number };

export function rateLimit(opts?: { limit?: number; windowMs?: number }) {
  const limit = opts?.limit ?? 60; // requests
  const windowMs = opts?.windowMs ?? 60_000; // per minute
  const buckets = new Map<string, Bucket>();

  function keyFrom(req: Request): string {
    const bearer = req.header('authorization')?.replace(/^Bearer\s+/i, '');
    const xk = req.header('x-api-key');
    return (xk || bearer || req.ip || 'anon').toString();
  }

  return function limiter(req: Request, res: Response, next: NextFunction) {
    const k = keyFrom(req);
    const now = Date.now();
    let b = buckets.get(k);
    if (!b || now >= b.resetAt) {
      b = { count: 0, resetAt: now + windowMs };
      buckets.set(k, b);
    }
    if (b.count >= limit) {
      const retry = Math.max(0, b.resetAt - now);
      res.setHeader('Retry-After', Math.ceil(retry / 1000).toString());
      return res.status(429).json({ ok: false, error: 'rate_limited', retryAfterMs: retry });
    }
    b.count++;
    next();
  };
}

===== src/middleware/idempotency.ts =====
import { Request, Response, NextFunction } from "express";
import Redis from "ioredis";

const redisUrl = process.env.REDIS_URL || "";
const redis = redisUrl ? new Redis(redisUrl) : null;
const mem = new Map<string, any>();

export async function requireIdempotency(req: Request, res: Response, next: NextFunction) {
  const key = (req.header("X-Idempotency-Key") || "").trim();
  if (!key) return res.status(400).json({ ok: false, error: "missing_idempotency_key" });

  // try redis
  if (redis) {
    const existing = await redis.get(`idem:${key}`);
    if (existing) {
      return res.json(JSON.parse(existing));
    }
    // mark with placeholder to avoid races. store TTL 1h
    await redis.set(`idem:${key}`, JSON.stringify({ status: "processing" }), "EX", 3600, "NX");
    // attach key to req for handler to set final value
    (req as any).idempotencyKey = key;
    return next();
  }

  // memory fallback
  if (mem.has(key)) return res.json(mem.get(key));
  mem.set(key, { status: "processing" });
  (req as any).idempotencyKey = key;
  return next();
}

// helper to save response after success
export async function storeIdempotencyResult(req: Request, result: any) {
  const key = (req as any).idempotencyKey;
  if (!key) return;
  if (redis) {
    await redis.set(`idem:${key}`, JSON.stringify(result), "EX", 60 * 60);
    return;
  }
  mem.set(key, result);
}
===== src/middleware/auth.ts =====
import { Request, Response, NextFunction } from 'express';

/**
 * API key guard with broad compatibility and safe debug logs.
 * Accepts key via:
 *  - Header: X-Api-Key
 *  - Header: Authorization: Bearer <key>
 *  - Query: ?api_key=<key> or ?apikey=<key>
 * Supports multiple keys via env `API_KEYS` (comma-separated) in addition to `API_KEY` and `CODEX_DISPATCH_TOKEN`.
 */
export function requireApiKey(req: Request, res: Response, next: NextFunction) {
  const envKeys = ((process.env.API_KEYS || '')
    .split(',')
    .map(s => s.trim())
    .filter(Boolean));

  if (process.env.API_KEY && process.env.API_KEY.trim()) {
    envKeys.push(process.env.API_KEY.trim());
  }
  if (process.env.CODEX_DISPATCH_TOKEN && process.env.CODEX_DISPATCH_TOKEN.trim()) {
    envKeys.push(process.env.CODEX_DISPATCH_TOKEN.trim());
  }

  const bearer = (req.header('authorization') || '')
    .replace(/\s+/g, ' ')
    .replace(/^Bearer\s+/i, '')
    .trim();
  const headerKey = (req.header('x-api-key') || req.header('X-Api-Key') || '').toString().trim();
  const queryKey = (req.query.api_key as string) || (req.query.apikey as string) || '';
  const provided = (headerKey || bearer || queryKey || '').trim();

  try {
    (req as any).log?.info?.({
      action: 'auth.requireApiKey.debug',
      hasHeaderKey: !!headerKey,
      hasBearer: !!bearer,
      hasQueryKey: !!queryKey,
      envKeysConfigured: envKeys.length,
      path: req.originalUrl,
      method: req.method,
    });
  } catch {}

  if (!envKeys.length) {
    return res.status(500).json({ ok: false, error: 'Missing API_KEY' });
  }
  if (!provided) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }
  const match = envKeys.some(k => k && k === provided);
  if (!match) return res.status(401).json({ ok: false, error: 'Unauthorized' });
  return next();
}

/**
 * Prefer OIDC ID token (Authorization: Bearer <JWT>) and fallback to API Key.
 * Audience from API_AUDIENCE (comma-separated allowed). Issuer allowlist via ALLOWED_ISSUERS.
 */
export async function requireAuth(req: Request, res: Response, next: NextFunction) {
  const bearer = (req.header('authorization') || '')
    .replace(/\s+/g, ' ')
    .replace(/^Bearer\s+/i, '')
    .trim();
  if (bearer) {
    try {
      const { OAuth2Client } = require('google-auth-library');
      const client = new OAuth2Client();
      const audRaw = (process.env.API_AUDIENCE || process.env.CHAT_AUDIENCE || '').trim();
      const audiences = audRaw ? audRaw.split(',').map((s: string) => s.trim()).filter(Boolean) : undefined;
      const ticket = await client.verifyIdToken({ idToken: bearer, audience: audiences });
      const payload = ticket.getPayload();
      const allowedIss = (process.env.ALLOWED_ISSUERS || 'https://accounts.google.com,accounts.google.com')
        .split(',').map((s: string) => s.trim());
      if (!payload || (allowedIss.length && !allowedIss.includes(String(payload.iss)))) {
        return res.status(401).json({ ok: false, error: 'Invalid issuer' });
      }
      (req as any).principal = { sub: payload.sub, email: payload.email, iss: payload.iss, aud: payload.aud };
      return next();
    } catch (e: any) {
      (req as any).log?.warn?.({ action: 'auth.requireAuth.jwt.verify_failed', error: e?.message || String(e) });
      // fallthrough to API key
    }
  }
  return requireApiKey(req, res, next);
}
===== src/middleware/logging.ts =====
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';
import onFinished from 'on-finished';

// declare module fix for 'on-finished'
declare module 'on-finished';

/**
 * Middleware di logging/audit unificato
 * - Logga azione, endpoint, utente impersonato, requestId
 * - Logga risposta (status, durata)
 * - Traccia errori uncaught
 * - Salva log in req.zlog per uso modulare
 * - Output JSON, pronto per GCP Logging
 */
export function loggingMiddleware(req: Request, res: Response, next: NextFunction) {
  const start = process.hrtime.bigint();
  const requestId = req.headers['x-request-id'] as string || uuidv4();
  (req as any).requestId = requestId;

  const impersonated = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || null;

  // Log base
  const logEntry: any = {
    ts: new Date().toISOString(),
    requestId,
    method: req.method,
    endpoint: req.originalUrl,
    action: `${req.method} ${req.originalUrl}`,
    impersonated,
    ip: req.ip,
    userAgent: req.headers['user-agent'] || null,
    body: req.body,
    status: undefined,
    durationMs: undefined,
    error: undefined,
  };
  // Salva log su req per uso nei moduli
  (req as any).zlog = logEntry;
  console.log('[AUDIT]', JSON.stringify({ ...logEntry, phase: 'request' }));

  // Logga risposta e durata
  onFinished(res, (err: Error | null, res: Response) => {
    const end = process.hrtime.bigint();
    const durationMs = Number(end - start) / 1e6;
    logEntry.status = res.statusCode;
    logEntry.durationMs = durationMs;
    if (err) {
      logEntry.error = err.message || String(err);
    }
    console.log('[AUDIT]', JSON.stringify({ ...logEntry, phase: 'response' }));
  });

  // Catch errori uncaught (Express li passa a next(err))
  try {
    next();
  } catch (err: any) {
    logEntry.error = err?.message || String(err);
    logEntry.status = 500;
    logEntry.durationMs = Number(process.hrtime.bigint() - start) / 1e6;
    console.log('[AUDIT]', JSON.stringify({ ...logEntry, phase: 'error' }));
    throw err;
  }
}
===== src/core/output.ts =====
export function ok(data: any) {
  return { ok: true, data };
}
export function fail(msg: string, details?: any) {
  return { ok: false, error: msg, details: details || null };
}
===== src/core/tokens.ts =====
// src/core/tokens.ts
import { promises as fs } from 'fs';
import * as path from 'path';

export interface TokenParams {
  sampler?: string;
  steps?: number;
  cfg?: number;
  resolution?: string;
  seed?: number;
  hires_fix?: boolean;
  [k: string]: unknown;
}

export interface TokenDef {
  token: string;                       // es: "<ZAN_RIRI>"
  description?: string;
  style_pack?: string;
  reference_image?: string;            // es: "memory/tokens/assets/zan_riri_ref.png"
  positive_prompt?: string;
  negative_prompt?: string;
  params?: TokenParams;
  lora?: { name?: string; weight?: number; notes?: string };
  sora_append?: string;
  version?: string;
  tags?: string[];
  [k: string]: unknown;
}

export type TokenMap = Record<string, TokenDef>;

const TOKENS_DIR_DEFAULT = 'memory/tokens';

/**
 * Carica tutti i .json nella cartella tokensDir e ritorna una mappa { "<TOKEN>": def }
 */
export async function loadTokens(tokensDir: string = TOKENS_DIR_DEFAULT): Promise<TokenMap> {
  const map: TokenMap = {};
  const dir = path.resolve(tokensDir);
  let files: string[] = [];
  try {
    const list = await fs.readdir(dir);
    files = list.filter((f) => f.toLowerCase().endsWith('.json'));
  } catch {
    return map;
  }

  for (const file of files) {
    try {
      const full = path.join(dir, file);
      const raw = await fs.readFile(full, 'utf8');
      const def = JSON.parse(raw) as TokenDef;
      if (def && typeof def.token === 'string' && def.token.startsWith('<') && def.token.endsWith('>')) {
        map[def.token] = def;
      }
    } catch (e) {
      console.warn(`tokens: cannot load ${file}:`, (e as Error).message);
    }
  }
  return map;
}

/**
 * Espande un prompt sostituendo i placeholder (es. "<ZAN_RIRI>")
 */
export function expandPrompt(
  basePrompt: string,
  map: TokenMap,
  options?: { target?: 'sdxl' | 'sora' | 'generic' }
): {
  prompt: string;
  negative?: string;
  params?: TokenParams;
  reference_image?: string;
  used: string[];
} {
  const target = options?.target ?? 'generic';
  const tokensUsed = Array.from(new Set((basePrompt.match(/<[^>]+>/g) || [])));

  let prompt = basePrompt;
  let mergedNegative: string[] = [];
  let mergedParams: TokenParams = {};
  let referenceImage: string | undefined;

  for (const t of tokensUsed) {
    const def = map[t];
    if (!def) continue;

    if (def.reference_image) referenceImage = def.reference_image;

    if (def.positive_prompt) {
      prompt = prompt.replace(new RegExp(escapeRegExp(t), 'g'), def.positive_prompt);
    } else {
      prompt = prompt.replace(new RegExp(escapeRegExp(t), 'g'), '');
    }

    if (def.negative_prompt) mergedNegative.push(def.negative_prompt);
    if (def.params) mergedParams = { ...mergedParams, ...def.params };
    if (target === 'sora' && def.sora_append) {
      prompt = `${prompt.trim()}\n${def.sora_append.trim()}`;
    }
  }

  return {
    prompt: prompt.trim(),
    negative: mergedNegative.length ? mergedNegative.join(', ') : undefined,
    params: Object.keys(mergedParams).length ? mergedParams : undefined,
    reference_image: referenceImage,
    used: tokensUsed
  };
}

function escapeRegExp(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
===== src/test_calendar.ts =====
import request = require('supertest');
import express = require('express');
import { calendarRoutes } from './api/calendar';

describe('Calendar endpoints', () => {
  let app: express.Express;
  beforeAll(() => {
    app = express();
    app.use(express.json());
    calendarRoutes(app);
  });

  it('should fail update if missing params', async () => {
    const res = await request(app).post('/actions/calendar/update').send({});
    expect(res.status).toBe(400);
    expect(res.body.error).toMatch(/calendarId|eventId/);
  });

  it('should fail delete if missing params', async () => {
    const res = await request(app).post('/actions/calendar/delete').send({});
    expect(res.status).toBe(400);
    expect(res.body.error).toMatch(/calendarId|eventId/);
  });

  // Integration tests for update/delete would require real Google Calendar setup
});
===== src/googleAuth.ts =====
===== src/debug.ts =====
import { Express, Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from './google';
import { actionsWhoamiHandler } from './actions/debug/whoami';
import { requireApiKey } from './middleware/auth';
import { SecretManagerServiceClient } from '@google-cloud/secret-manager';

type CheckResult = { ok: boolean; error?: string; details?: any };

async function checkDrive(user: string): Promise<CheckResult> {
  try {
    const ic = await impersonatedClient(user, [
      'https://www.googleapis.com/auth/drive',
      'https://www.googleapis.com/auth/drive.file',
    ]);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const { data } = await drive.files.list({
      pageSize: 1,
      fields: 'files(id,name)',
      supportsAllDrives: true,
      includeItemsFromAllDrives: true,
    });
    return { ok: true, details: { sample: data.files?.[0] || null } };
  } catch (e: any) {
    return { ok: false, error: e?.message || String(e) };
  }
}

async function checkCalendar(user: string): Promise<CheckResult> {
  try {
    const ic = await impersonatedClient(user, [
      'https://www.googleapis.com/auth/calendar',
    ]);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });
    const { data } = await calendar.calendarList.list({ maxResults: 1 });
    return { ok: true, details: { sample: data.items?.[0]?.id || null } };
  } catch (e: any) {
    return { ok: false, error: e?.message || String(e) };
  }
}

async function checkGmail(user: string): Promise<CheckResult> {
  try {
    const ic = await impersonatedClient(user, [
      'https://www.googleapis.com/auth/gmail.send',
    ]);
    // Token obtainable implies DWD + scope OK for send
    const token = await (ic.auth as any).authorize();
    if (!token || !token.access_token) throw new Error('No access token');
    return { ok: true };
  } catch (e: any) {
    return { ok: false, error: e?.message || String(e) };
  }
}

async function checkChat(): Promise<CheckResult> {
  try {
    const auth = await google.auth.getClient({ scopes: ['https://www.googleapis.com/auth/chat.bot'] });
    const token = await auth.getAccessToken();
    if (!token || !token.token) throw new Error('No access token');
    return { ok: true };
  } catch (e: any) {
    return { ok: false, error: e?.message || String(e) };
  }
}

export function debugRoutes(app: Express) {
  // Service Account info + DWD validation
  app.get('/debug/sa-info', requireApiKey, async (req: Request, res: Response) => {
    try {
      const secretEnv = process.env.SA_JSON_SECRET || process.env.GOOGLE_SA_JSON_SECRET || '';
      let parsed: any | null = null;
      if (secretEnv && (secretEnv.trim().startsWith('{') || secretEnv.includes('"private_key"'))) {
        try { parsed = JSON.parse(secretEnv); } catch {/* fallthrough */}
      }
      if (!parsed) {
        const sm = new SecretManagerServiceClient();
        const projectId = await google.auth.getProjectId();
        if (!projectId) throw new Error('Unable to resolve GCP project id via ADC');
        const name = `projects/${projectId}/secrets/${secretEnv}/versions/latest`;
        const [access] = await sm.accessSecretVersion({ name });
        const payload = access.payload?.data?.toString() || '';
        if (!payload) throw new Error('Secret payload empty');
        parsed = JSON.parse(payload);
      }
      const info = {
        client_id: parsed.client_id || null,
        client_email: parsed.client_email || null,
        project_id: parsed.project_id || null,
      };

      const allowed = (process.env.ALLOWED_CLIENT_IDS || '')
        .split(',').map(s => s.trim()).filter(Boolean);
      const allowedMatch = info.client_id ? allowed.includes(info.client_id) : false;
      const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
      let aboutEmail: string | null = null;
      try {
        const ic = await impersonatedClient(user, [
          'https://www.googleapis.com/auth/drive',
          'https://www.googleapis.com/auth/drive.file',
        ]);
        const drive = google.drive({ version: 'v3', auth: ic.auth });
        const about = await drive.about.get({ fields: 'user', supportsAllDrives: true } as any);
        // @ts-ignore
        aboutEmail = (about.data.user && (about.data.user.emailAddress as string)) || null;
      } catch (e: any) {
        (req as any).log?.warn?.({ action: 'debug.sa-info.drive.about', error: e?.message || String(e) });
      }

      // Structured log summary
      const logEntry = { action: 'debug.sa-info', ...info, allowedConfigured: allowed.length, allowedMatch, aboutEmail };
      if (allowed.length && !allowedMatch) (req as any).log?.warn?.(logEntry); else (req as any).log?.info?.(logEntry);

      return res.json({ ok: true, info, allowedMatch, aboutEmail });
    } catch (e: any) {
      (req as any).log?.error?.({ action: 'debug.sa-info', error: e?.message || String(e) });
      return res.status(500).json({ ok: false, error: e?.message || 'sa-info failed' });
    }
  });
  // Summarize effective identities and quick capability probe
  app.get('/debug/whoami', requireApiKey, async (_req: Request, res: Response) => {
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const out: any = {
      impersonatedUser: user || null,
      drive: null,
      calendar: null,
      gmail: null,
      sharedDrive: null,
    };
    try {
      const ic = await impersonatedClient(user, [
        'https://www.googleapis.com/auth/drive',
      ]);
      const drive = google.drive({ version: 'v3', auth: ic.auth });
      const about = await drive.about.get({ fields: 'user,storageQuota', supportsAllDrives: true } as any);
      out.drive = { user: about.data.user || null };

      // If a Shared Drive ID is configured, verify access and basic metadata
      const sharedId = process.env.ZANTARA_SHARED_DRIVE_ID;
      if (sharedId) {
        try {
          const dr = await (drive as any).drives.get({ driveId: sharedId });
          out.sharedDrive = { id: sharedId, name: dr.data?.name || null };
        } catch (e: any) {
          out.sharedDrive = { id: sharedId, error: e?.message || String(e) };
        }
      }
    } catch (e: any) {
      out.drive = { error: e?.message || String(e) };
    }

    try {
      const ic = await impersonatedClient(user, [ 'https://www.googleapis.com/auth/calendar' ]);
      const calendar = google.calendar({ version: 'v3', auth: ic.auth });
      const cl = await calendar.calendarList.list({ maxResults: 10 });
      const items = cl.data.items || [];
      const visibleCalendarIds = items.map((c: any) => ({ id: c.id, summary: c.summary, primary: !!c.primary })).slice(0, 10);
      const primary = items.find((c: any) => c.primary) || null;
      out.calendar = { sampleCalendarId: items?.[0]?.id || null, visibleCalendarIds, primary: primary ? { id: primary.id, summary: primary.summary } : null };
    } catch (e: any) {
      out.calendar = { error: e?.message || String(e) };
    }

    try {
      const ic = await impersonatedClient(user, [ 'https://www.googleapis.com/auth/gmail.send' ]);
      const token = await (ic.auth as any).authorize();
      out.gmail = { accessToken: !!token?.access_token };
    } catch (e: any) {
      out.gmail = { error: e?.message || String(e) };
    }

    res.json({ ok: true, whoami: out, ts: new Date().toISOString() });
  });
  app.get('/debug/self-check', async (_req: Request, res: Response) => {
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const env = {
      DRIVE_FOLDER_ID: !!process.env.DRIVE_FOLDER_ID,
      BALI_ZERO_CALENDAR_ID: !!process.env.BALI_ZERO_CALENDAR_ID,
      MEMORY_DRIVE_FOLDER_ID: !!process.env.MEMORY_DRIVE_FOLDER_ID,
      ZANTARA_SHARED_DRIVE_ID: !!process.env.ZANTARA_SHARED_DRIVE_ID,
      IMPERSONATE_USER: !!process.env.IMPERSONATE_USER,
      GMAIL_SENDER: !!process.env.GMAIL_SENDER,
      SA_JSON_SECRET: !!process.env.SA_JSON_SECRET || !!process.env.GOOGLE_SA_JSON_SECRET,
      GOOGLE_CLIENT_EMAIL: !!process.env.GOOGLE_CLIENT_EMAIL,
      GOOGLE_PRIVATE_KEY: !!process.env.GOOGLE_PRIVATE_KEY,
      GOOGLE_CLOUD_PROJECT: !!process.env.GOOGLE_CLOUD_PROJECT,
    };

    const results: Record<string, CheckResult> = {};
    results.drive = user ? await checkDrive(user) : { ok: false, error: 'Missing IMPERSONATE_USER/GMAIL_SENDER' };
    results.calendar = user ? await checkCalendar(user) : { ok: false, error: 'Missing IMPERSONATE_USER/GMAIL_SENDER' };
    results.gmail = user ? await checkGmail(user) : { ok: false, error: 'Missing IMPERSONATE_USER/GMAIL_SENDER' };
    results.chat = await checkChat();

    res.json({ ok: true, env, results, ts: new Date().toISOString() });
  });
  // Actions endpoint: whoami (protected with API key)
  app.get('/actions/debug/whoami', requireApiKey as any, actionsWhoamiHandler as any);
}

export function debugRawRoutes(app: Express) {
  app.get('/debug/env/raw', requireApiKey, (_req: Request, res: Response) => {
    res.json({
      DRIVE_FOLDER_ID: process.env.DRIVE_FOLDER_ID || null,
      MEMORY_DRIVE_FOLDER_ID: process.env.MEMORY_DRIVE_FOLDER_ID || null,
      BALI_ZERO_CALENDAR_ID: process.env.BALI_ZERO_CALENDAR_ID || null,
      ZANTARA_SHARED_DRIVE_ID: process.env.ZANTARA_SHARED_DRIVE_ID || null,
    });
  });
}
===== src/chat.ts =====
===== src/geminiBridge.ts =====
===== src/test_routes.ts =====
===== src/notes.ts =====
import { google } from 'googleapis';
import { Firestore } from '@google-cloud/firestore';
import { impersonatedClient } from './google';
import { Document, HeadingLevel, Packer, Paragraph, TextRun } from 'docx';
import { Readable } from 'stream';

const DOCX_MIME = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';

export type NoteEntry = {
  owner: string;
  title: string;
  content: string;
  ts: number; // epoch ms
  dateKey: string; // YYYY-MM-DD
};

function canonicalOwner(input?: string | null): string | null {
  if (!input) return null;
  const s = String(input).trim();
  if (!s) return null;
  const nameOnly = s.replace(/@balizero\.com$/i, '').trim();
  const key = nameOnly.toLowerCase().replace(/[^a-z]/g, '');
  const MAP: Record<string, string> = {
    boss: 'BOSS', zero: 'BOSS',
    riri: 'RIRI', rina: 'RINA',
    gianluca: 'GIANLUCA', gl: 'GIANLUCA',
    ari: 'ARI', surya: 'SURYA', amanda: 'AMANDA'
  };
  return MAP[key] || nameOnly.toUpperCase();
}

export function ymd(date = new Date()): string {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, '0');
  const d = String(date.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

export function briefTitle(owner: string, dateStr: string): string {
  return `Brief – ${owner} – ${dateStr}.docx`;
}

export function reportTitle(owner: string, dateStr: string): string {
  return `Report – ${owner} – ${dateStr}.docx`;
}

export async function addNote(ownerRaw: string, title: string, content: string, at = Date.now()) {
  const owner = canonicalOwner(ownerRaw) || ownerRaw.toString().toUpperCase();
  const db = new Firestore();
  const dateStr = ymd(new Date(at));
  const entry: NoteEntry = { owner, title, content, ts: at, dateKey: dateStr };
  await db.collection('notes').add(entry);
  return entry;
}

async function driveClient() {
  const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
  const ic = await impersonatedClient(user, [
    'https://www.googleapis.com/auth/drive',
  ]);
  return google.drive({ version: 'v3', auth: ic.auth });
}

async function findOrCreateOwnerFolder(drive: any, rootId: string, owner: string): Promise<string> {
  const escQ = (s: string) => s.replace(/'/g, "\\'");
  const name = owner.trim();
  const q = `name='${escQ(name)}' and mimeType='application/vnd.google-apps.folder' and '${rootId}' in parents and trashed=false`;
  const listParams: any = {
    q,
    fields: 'files(id,name)',
    supportsAllDrives: true,
    includeItemsFromAllDrives: true,
  };
  const { data } = await drive.files.list(listParams);
  if (data.files && data.files[0]?.id) return data.files[0].id as string;
  const { data: created } = await drive.files.create({
    requestBody: { name, mimeType: 'application/vnd.google-apps.folder', parents: [rootId] },
    fields: 'id',
    supportsAllDrives: true,
  });
  return created.id as string;
}

async function uploadOrReplaceDocx(drive: any, parentId: string, name: string, buffer: Buffer) {
  // Search by exact name within the owner folder
  const escQ = (s: string) => s.replace(/'/g, "\\'");
  const q = `name='${escQ(name)}' and '${parentId}' in parents and trashed=false`;
  const { data: list } = await drive.files.list({ q, fields: 'files(id,name,parents)', supportsAllDrives: true, includeItemsFromAllDrives: true } as any);
  if (list.files && list.files[0]?.id) {
    const fileId = list.files[0].id as string;
    const stream = Readable.from(buffer);
    await drive.files.update({ fileId, media: { mimeType: DOCX_MIME, body: stream }, supportsAllDrives: true });
    return { id: fileId, updated: true };
  }
  const stream = Readable.from(buffer);
  const { data: created } = await drive.files.create({
    requestBody: { name, mimeType: DOCX_MIME, parents: [parentId] },
    media: { mimeType: DOCX_MIME, body: stream },
    fields: 'id,webViewLink',
    supportsAllDrives: true,
  });
  return { id: created.id as string, created: true, webViewLink: created.webViewLink };
}

export async function listNotes(ownerRaw: string, dateStr: string) {
  const owner = canonicalOwner(ownerRaw) || ownerRaw.toString().toUpperCase();
  const db = new Firestore();
  const snap = await db.collection('notes')
    .where('owner', '==', owner)
    .where('dateKey', '==', dateStr)
    .get();
  const items = snap.docs.map(d => d.data() as NoteEntry);
  items.sort((a,b) => (a.ts||0)-(b.ts||0));
  return items;
}

export async function regenerateBriefDocx(ownerRaw: string, dateStr = ymd()) {
  const owner = canonicalOwner(ownerRaw) || ownerRaw.toString().toUpperCase();
  const notes = await listNotes(owner, dateStr);
  const title = briefTitle(owner, dateStr);

  const doc = new Document({ sections: [
    {
      properties: {},
      children: [
        new Paragraph({ text: `Brief – ${owner} – ${dateStr}`, heading: HeadingLevel.HEADING_1 }),
        ...notes.map(n => new Paragraph({ children: [ new TextRun({ text: `• ${n.title}: `, bold: true }), new TextRun(n.content) ] })),
      ],
    },
  ]});
  const buffer = await Packer.toBuffer(doc);

  const drive = await driveClient();
  const rootId = process.env.MEMORY_DRIVE_FOLDER_ID;
  if (!rootId) throw new Error('Missing MEMORY_DRIVE_FOLDER_ID');
  const folderId = await findOrCreateOwnerFolder(drive, rootId, owner);
  const up = await uploadOrReplaceDocx(drive, folderId, title, buffer);
  return { ok: true, title, owner, date: dateStr, fileId: up.id, folderId } as any;
}

export async function generateReportDocx(ownerRaw: string, dateStr = ymd(), summaryText?: string) {
  const owner = canonicalOwner(ownerRaw) || ownerRaw.toString().toUpperCase();
  const notes = await listNotes(owner, dateStr);
  const title = reportTitle(owner, dateStr);

  const paragraphs: Paragraph[] = [
    new Paragraph({ text: `Report – ${owner} – ${dateStr}`, heading: HeadingLevel.HEADING_1 }),
  ];
  if (summaryText) {
    paragraphs.push(new Paragraph(''));
    paragraphs.push(new Paragraph({ text: 'Sintesi', heading: HeadingLevel.HEADING_2 }));
    summaryText.split(/\n+/).forEach(line => paragraphs.push(new Paragraph(line)));
  }
  if (notes.length) {
    paragraphs.push(new Paragraph(''));
    paragraphs.push(new Paragraph({ text: 'Dettaglio del giorno', heading: HeadingLevel.HEADING_2 }));
    notes.forEach(n => {
      paragraphs.push(new Paragraph({ children: [ new TextRun({ text: `• ${n.title}: `, bold: true }), new TextRun(n.content) ] }));
    });
  }

  const doc = new Document({ sections: [{ children: paragraphs }] });
  const buffer = await Packer.toBuffer(doc);

  const drive = await driveClient();
  const rootId = process.env.MEMORY_DRIVE_FOLDER_ID;
  if (!rootId) throw new Error('Missing MEMORY_DRIVE_FOLDER_ID');
  const folderId = await findOrCreateOwnerFolder(drive, rootId, owner);
  const up = await uploadOrReplaceDocx(drive, folderId, title, buffer);
  return { ok: true, title, owner, date: dateStr, fileId: up.id, folderId } as any;
}
===== src/types.ts =====
===== src/test.ts =====
import request = require('supertest');
import express = require('express');
import { driveRoutes } from './api/drive';

describe('Drive permissions endpoints', () => {
  let app: express.Express;
  beforeAll(() => {
    app = express();
    app.use(express.json());
    driveRoutes(app);
  });

  it('should fail if missing params (add)', async () => {
    const res = await request(app).post('/actions/drive/permissions/add').send({});
    expect(res.status).toBe(400);
    expect(res.body.error).toMatch(/fileId/);
  });

  it('should fail if missing params (remove)', async () => {
    const res = await request(app).post('/actions/drive/permissions/remove').send({});
    expect(res.status).toBe(400);
    expect(res.body.error).toMatch(/fileId/);
  });

  // NOTE: The following tests require valid Google Drive setup and will fail without proper mocks or env
  // it('should add and remove permission (integration)', async () => {
  //   const fileId = 'test-file-id';
  //   const email = 'test@example.com';
  //   const role = 'reader';
  //   const addRes = await request(app).post('/actions/drive/permissions/add').send({ fileId, email, role });
  //   expect(addRes.status).toBe(200);
  //   expect(addRes.body.permissionId).toBeDefined();
  //   const removeRes = await request(app).post('/actions/drive/permissions/remove').send({ fileId, permissionId: addRes.body.permissionId });
  //   expect(removeRes.status).toBe(200);
  // });
});
===== src/google.ts =====
// Minimal stub for impersonatedClient to unblock tests
export async function impersonatedClient(user: string, scopes: string[]): Promise<{ auth: any }> {
  return { auth: {} };
}
===== src/actions/calendar/availability.ts =====
export default {}===== src/actions/calendar/quickadd.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function quickAddCalendarEventHandler(req: Request, res: Response) {
  try {
    const text = (req.body?.text as string) || '';
    const calendarId = (req.body?.calendarId as string) || process.env.BALI_ZERO_CALENDAR_ID;
    if (!text || !calendarId) return res.status(400).json({ ok: false, error: 'Missing text/calendarId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });
    const { data } = await calendar.events.quickAdd({ calendarId, text } as any);
    (req as any).log?.info?.({ action: 'calendar.quickadd', calendarId, id: (data as any)?.id, status: (data as any)?.status });
    return res.json({ id: (data as any)?.id, status: (data as any)?.status, htmlLink: (data as any)?.htmlLink });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.quickadd', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.quickadd failed', details: gerr || undefined });
  }
}

===== src/actions/calendar/reminders.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function calendarRemindersHandler(req: Request, res: Response) {
  try {
    const { calendarId, eventId, minutesBefore, method } = req.body || {};
    if (!calendarId || !eventId || !minutesBefore) return res.status(400).json({ ok: false, error: 'Missing calendarId/eventId/minutesBefore' });
    const m = String(method || 'popup');
    const minutes = parseInt(String(minutesBefore), 10);
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });
    const { data } = await calendar.events.patch({
      calendarId,
      eventId,
      requestBody: { reminders: { useDefault: false, overrides: [{ method: m, minutes }] } } as any,
    } as any);
    (req as any).log?.info?.({ action: 'calendar.reminders', calendarId, eventId, method: m, minutes });
    return res.json({ ok: true, id: data.id, reminders: (data as any)?.reminders });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.reminders', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.reminders failed', details: gerr || undefined });
  }
}

===== src/actions/calendar/create.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

type CreateBody = {
  calendarId?: string;
  title: string;
  start: string;
  end: string;
  attendees?: string[] | string;
  description?: string;
};

function normalizeAttendees(input?: string[] | string): { email: string }[] | undefined {
  if (!input) return undefined;
  const toArray = Array.isArray(input)
    ? input
    : String(input)
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);
  if (!toArray.length) return undefined;
  const unique = Array.from(new Set(toArray.map(s => s.toLowerCase())));
  return unique.map(email => ({ email }));
}

export async function createCalendarEventHandler(req: Request, res: Response) {
  try {
    const body = (req.body || {}) as Partial<CreateBody>;
    const calendarId = body.calendarId || process.env.BALI_ZERO_CALENDAR_ID;
    if (!calendarId) {
      return res.status(400).json({ ok: false, error: 'Missing calendarId and BALI_ZERO_CALENDAR_ID' });
    }

    const title = (body.title || '').toString().trim();
    const start = (body.start || '').toString().trim();
    const end = (body.end || '').toString().trim();
    if (!title || !start || !end) {
      return res.status(400).json({ ok: false, error: 'Missing required fields: title, start, end' });
    }

    const attendees = normalizeAttendees(body.attendees);
    const description = (body.description || '').toString() || undefined;

    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });

    const insertRes = await calendar.events.insert({
      calendarId,
      requestBody: {
        summary: title,
        description,
        start: { dateTime: start },
        end: { dateTime: end },
        attendees,
        reminders: { useDefault: true },
      },
      sendUpdates: 'none',
    } as any);

    const data: any = insertRes.data || {};
    const payload = {
      id: data.id as string | undefined,
      status: (data.status as string | undefined) || undefined,
      htmlLink: (data.htmlLink as string | undefined) || undefined,
    };
    (req as any).log?.info?.({ action: 'calendar.create', calendarId, title, status: payload.status, eventId: payload.id, htmlLink: payload.htmlLink });
    return res.json(payload);
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.create', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.create failed', details: gerr || undefined });
  }
}
===== src/actions/calendar/list.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function listCalendarEventsHandler(req: Request, res: Response) {
  try {
    const calendarId = (req.query.calendarId as string) || process.env.BALI_ZERO_CALENDAR_ID;
    if (!calendarId) return res.status(400).json({ ok: false, error: 'Missing calendarId and BALI_ZERO_CALENDAR_ID' });

    const timeMin = (req.query.timeMin as string) || new Date().toISOString();
    const maxResults = Math.max(1, Math.min(parseInt(String(req.query.maxResults || '10'), 10) || 10, 100));

    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar.readonly', 'https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });

    const { data } = await calendar.events.list({
      calendarId,
      timeMin,
      maxResults,
      singleEvents: true,
      orderBy: 'startTime',
    } as any);

    const events = (data.items || []).map((ev: any) => ({
      id: ev.id,
      summary: ev.summary,
      start: ev.start?.dateTime || ev.start?.date || null,
      end: ev.end?.dateTime || ev.end?.date || null,
      location: ev.location || null,
      attendees: Array.isArray(ev.attendees) ? ev.attendees.map((a: any) => ({ email: a.email, responseStatus: a.responseStatus })) : undefined,
      htmlLink: ev.htmlLink,
    }));

    (req as any).log?.info?.({ action: 'calendar.list', calendarId, timeMin, maxResults, count: events.length });
    return res.json({ ok: true, events });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.list', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.list failed', details: gerr || undefined });
  }
}

===== src/actions/calendar/freebusy.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function calendarFreebusyHandler(req: Request, res: Response) {
  try {
    const { calendarIds, start, end } = req.body || {};
    if (!Array.isArray(calendarIds) || !calendarIds.length || !start || !end) {
      return res.status(400).json({ ok: false, error: 'Missing calendarIds/start/end' });
    }
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });
    const items = calendarIds.map((id: string) => ({ id }));
    const { data } = await calendar.freebusy.query({ requestBody: { timeMin: String(start), timeMax: String(end), items } as any });
    return res.json({ ok: true, result: data });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.freebusy', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.freebusy failed', details: gerr || undefined });
  }
}

===== src/actions/calendar/subscribe.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function calendarSubscribeHandler(req: Request, res: Response) {
  try {
    const { calendarId, colorId, selected } = req.body || {};
    if (!calendarId) return res.status(400).json({ ok: false, error: 'Missing calendarId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });
    const requestBody: any = { id: String(calendarId) };
    if (colorId) requestBody.colorId = String(colorId);
    if (typeof selected !== 'undefined') requestBody.selected = !!selected;
    const { data } = await calendar.calendarList.insert({ requestBody } as any);
    (req as any).log?.info?.({ action: 'calendar.subscribe', calendarId, resultId: data.id });
    return res.json({ ok: true, calendarListEntry: data });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.subscribe', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.subscribe failed', details: gerr || undefined });
  }
}

===== src/actions/calendar/update.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

function normalizeAttendees(input?: string[] | string): { email: string }[] | undefined {
  if (!input) return undefined;
  const toArray = Array.isArray(input) ? input : String(input).split(',').map(s => s.trim()).filter(Boolean);
  const unique = Array.from(new Set(toArray.map(s => s.toLowerCase())));
  return unique.map(email => ({ email }));
}

export async function updateCalendarEventHandler(req: Request, res: Response) {
  try {
    const { eventId } = req.body || {};
    const calendarId = (req.body?.calendarId as string) || process.env.BALI_ZERO_CALENDAR_ID;
    if (!calendarId || !eventId) return res.status(400).json({ ok: false, error: 'Missing calendarId/eventId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });

    const { title, start, end, attendees, description } = req.body || {};
    const requestBody: any = {};
    if (title) requestBody.summary = String(title);
    if (description) requestBody.description = String(description);
    if (start) requestBody.start = { dateTime: String(start) };
    if (end) requestBody.end = { dateTime: String(end) };
    const atts = normalizeAttendees(attendees);
    if (atts) requestBody.attendees = atts;

    const { data } = await calendar.events.patch({ calendarId, eventId, requestBody } as any);
    (req as any).log?.info?.({ action: 'calendar.update', calendarId, eventId, status: data.status });
    return res.json({ id: data.id, status: data.status, htmlLink: data.htmlLink });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.update', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.update failed', details: gerr || undefined });
  }
}

===== src/actions/calendar/delete.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function deleteCalendarEventHandler(req: Request, res: Response) {
  try {
    const { eventId } = req.body || {};
    const calendarId = (req.body?.calendarId as string) || process.env.BALI_ZERO_CALENDAR_ID;
    if (!calendarId || !eventId) return res.status(400).json({ ok: false, error: 'Missing calendarId/eventId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/calendar']);
    const calendar = google.calendar({ version: 'v3', auth: ic.auth });
    await calendar.events.delete({ calendarId, eventId } as any);
    (req as any).log?.info?.({ action: 'calendar.delete', calendarId, eventId });
    return res.json({ ok: true });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'calendar.delete', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'calendar.delete failed', details: gerr || undefined });
  }
}

===== src/actions/memory/entry_merge.ts =====
import { Request, Response } from "express";
import { Firestore } from "@google-cloud/firestore";
import { google } from "googleapis";
import { Readable } from "stream";
import { impersonatedClient } from "../../google";

export async function memoryEntryMergeHandler(req: Request, res: Response) {
  try {
    const { userId, timestamps, mergeTitle } = req.body || {};
    if (!userId || !Array.isArray(timestamps) || !timestamps.length) {
      return res
        .status(400)
        .json({ ok: false, error: "Missing userId/timestamps[]" });
    }
    const title = String(mergeTitle || "Merged Notes");
    const db = new Firestore();
    const coll = db
      .collection("memory_entries")
      .doc(String(userId))
      .collection("entries");
    const docs = await Promise.all(
      timestamps.map((ts: any) => coll.doc(String(ts)).get())
    );
    const lines: string[] = [];
    for (const d of docs) {
      if (!d.exists) continue;
      const e = d.data() as any;
      lines.push(`# ${new Date(e.ts).toISOString()}\n${String(e.text)}\n`);
    }
    const md = lines.join("\n");
    const folderId =
      process.env.MEMORY_DRIVE_FOLDER_ID || process.env.DRIVE_FOLDER_ID || "";
    if (!folderId)
      return res
        .status(500)
        .json({ ok: false, error: "Missing MEMORY_DRIVE_FOLDER_ID" });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || "";
    const ic = await impersonatedClient(user, [
      "https://www.googleapis.com/auth/drive",
    ]);
    const drive = google.drive({ version: "v3", auth: ic.auth });
    const stream = Readable.from(Buffer.from(md, "utf8"));
    const { data } = await drive.files.create({
      requestBody: { name: `${title}.md`, parents: [folderId] },
      media: { mimeType: "text/markdown", body: stream },
      fields: "id,name,webViewLink",
      supportsAllDrives: true,
    } as any);
    return res.json({
      ok: true,
      id: (data as any).id,
      name: (data as any).name,
      webViewLink: (data as any).webViewLink,
    });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    return res
      .status(status)
      .json({ ok: false, error: e?.message || "memory.entry.merge failed" });
  }
}
===== src/actions/memory/entries/tag.ts =====

import { Request, Response } from 'express';
import { Firestore } from '@google-cloud/firestore';

export async function memoryEntryTagHandler(req: Request, res: Response) {
  try {
    const { userId, entryId, tags } = req.body || {};
    if (!userId || !entryId || !Array.isArray(tags)) return res.status(400).json({ ok: false, error: 'Missing userId/entryId/tags[]' });
    const db = new Firestore();
    await db.collection('memory_entries').doc(String(userId)).collection('entries').doc(String(entryId)).update({ tags });
    return res.json({ ok: true });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'memory.entry.tag failed' });
  }
}
===== src/actions/memory/entries/search.ts =====

import { Request, Response } from 'express';
import { Firestore } from '@google-cloud/firestore';

export async function memoryEntrySearchHandler(req: Request, res: Response) {
  try {
    const { userId, query, tags } = { userId: req.query.userId || req.body?.userId, query: req.query.query || req.query.q || req.body?.query, tags: req.query.tags || req.body?.tags } as any;
    if (!userId || !query) return res.status(400).json({ ok: false, error: 'Missing userId/query' });
    const db = new Firestore();
    const snap = await db.collection('memory_entries').doc(String(userId)).collection('entries').orderBy('ts','desc').limit(500).get();
    const q = String(query).toLowerCase();
    const tagSet = Array.isArray(tags) ? new Set(tags.map((t: any)=>String(t).toLowerCase())) : null;
    const items = snap.docs.map(d=>d.data()).filter((e:any)=> String(e.text||'').toLowerCase().includes(q) && (!tagSet || (Array.isArray(e.tags)&&e.tags.some((t:string)=>tagSet.has(String(t).toLowerCase())))) );
    return res.json({ ok: true, items });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'memory.entry.search failed' });
  }
}
===== src/actions/memory/entries/summary.ts =====

import { Request, Response } from 'express';
import { Firestore } from '@google-cloud/firestore';

export async function memoryWeeklySummaryHandler(req: Request, res: Response) {
  try {
    const userId = (req.query.userId as string) || (req.body?.userId as string) || '';
    if (!userId) return res.status(400).json({ ok: false, error: 'Missing userId' });
    const db = new Firestore();
    const now = Date.now();
    const weekAgo = now - 7*24*60*60*1000;
    const snap = await db.collection('memory_entries').doc(String(userId)).collection('entries').where('ts','>=', weekAgo).orderBy('ts','desc').limit(1000).get();
    const items = snap.docs.map(d=>d.data() as any);
    // naive summary: list titles/bullets from first sentence chunks
    const bullets = items.slice(0,50).map(e => `• ${new Date(e.ts).toISOString().slice(0,10)}: ${String(e.text).split('\n')[0].slice(0,120)}`);
    const summary = bullets.join('\n');
    return res.json({ ok: true, userId, count: items.length, summary });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'memory.weeklySummary failed' });
  }
}
===== src/actions/memory/entries/save.ts =====

import { Request, Response } from 'express';
import { Firestore } from '@google-cloud/firestore';

export async function memoryEntrySaveHandler(req: Request, res: Response) {
  try {
    const { userId, source, text, tags } = req.body || {};
    if (!userId || !text) return res.status(400).json({ ok: false, error: 'Missing userId/text' });
    const db = new Firestore();
    const ts = Date.now();
    const entry = { userId, source: source || null, text: String(text), tags: Array.isArray(tags) ? tags : [], ts };
    await db.collection('memory_entries').doc(String(userId)).collection('entries').doc(String(ts)).set(entry);
    (req as any).log?.info?.({ action: 'memory.entry.save', userId, ts });
    return res.json({ ok: true, id: String(ts) });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'memory.entry.save failed' });
  }
}
===== src/actions/memory/search.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function memorySearchHandler(req: Request, res: Response) {
  try {
    const q = (req.query.q as string) || '';
    if (!q) return res.status(400).json({ ok: false, error: 'Missing q' });
    const folderId = process.env.MEMORY_DRIVE_FOLDER_ID || process.env.DRIVE_FOLDER_ID || '';
    if (!folderId) return res.status(500).json({ ok: false, error: 'Missing MEMORY_DRIVE_FOLDER_ID' });

    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive.readonly']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });

    const escQ = (s: string) => s.replace(/'/g, "\\'");
    const query = `('${folderId}' in parents) and mimeType='text/markdown' and trashed=false and fullText contains '${escQ(q)}'`;

    const { data } = await drive.files.list({
      q: query,
      fields: 'files(id,name,createdTime,webViewLink)',
      pageSize: 50,
      includeItemsFromAllDrives: true,
      supportsAllDrives: true,
      corpora: 'allDrives',
    } as any);

    const items = (data.files || []).map((f: any) => ({ id: f.id, name: f.name, createdTime: f.createdTime, webViewLink: f.webViewLink }));
    (req as any).log?.info?.({ action: 'memory.search', q, folderId, count: items.length });
    return res.json({ ok: true, items });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'memory.search', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'memory.search failed', details: gerr || undefined });
  }
}

===== src/actions/memory/summary_monthly.ts =====
import { Request, Response } from "express";
import { Firestore } from "@google-cloud/firestore";

export async function memoryMonthlySummaryHandler(req: Request, res: Response) {
  try {
    const userId =
      (req.query.userId as string) || (req.body?.userId as string) || "";
    if (!userId)
      return res.status(400).json({ ok: false, error: "Missing userId" });
    const month =
      (req.query.month as string) || new Date().toISOString().slice(0, 7); // YYYY-MM
    const [y, m] = month.split("-").map((x: string) => parseInt(x, 10));
    const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0));
    const end = new Date(Date.UTC(y, m, 0, 23, 59, 59));
    const db = new Firestore();
    const snap = await db
      .collection("memory_entries")
      .doc(String(userId))
      .collection("entries")
      .where("ts", ">=", start.getTime())
      .where("ts", "<=", end.getTime())
      .orderBy("ts", "desc")
      .limit(2000)
      .get();
    const items = snap.docs
      .map((d) => d.data() as any)
      .filter((e) => !e.deleted);
    const bullets = items
      .slice(0, 200)
      .map(
        (e) =>
          `• ${new Date(e.ts).toISOString().slice(0, 10)}: ${String(e.text)
            .split("\n")[0]
            .slice(0, 140)}`
      );
    return res.json({
      ok: true,
      userId,
      month,
      count: items.length,
      summary: bullets.join("\n"),
    });
  } catch (e: any) {
    return res.status(500).json({
      ok: false,
      error: e?.message || "memory.summary.monthly failed",
    });
  }
}
===== src/actions/memory/entry_restore.ts =====

import { Request, Response } from 'express';
import { Firestore } from '@google-cloud/firestore';

export async function memoryEntryRestoreHandler(req: Request, res: Response) {
  try {
    const { userId, timestamp } = req.body || {};
    if (!userId || !timestamp) return res.status(400).json({ ok: false, error: 'Missing userId/timestamp' });
    const db = new Firestore();
    await db.collection('memory_entries').doc(String(userId)).collection('entries').doc(String(timestamp)).set({ deleted: false }, { merge: true });
    return res.json({ ok: true });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'memory.entry.restore failed' });
  }
}
===== src/actions/memory/entry_delete.ts =====

import { Request, Response } from 'express';
import { Firestore } from '@google-cloud/firestore';

export async function memoryEntryDeleteHandler(req: Request, res: Response) {
  try {
    const { userId, timestamp } = req.body || {};
    if (!userId || !timestamp) return res.status(400).json({ ok: false, error: 'Missing userId/timestamp' });
    const db = new Firestore();
    await db.collection('memory_entries').doc(String(userId)).collection('entries').doc(String(timestamp)).set({ deleted: true }, { merge: true });
    return res.json({ ok: true });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'memory.entry.delete failed' });
  }
}
===== src/actions/memory/save.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { Readable } from 'stream';
import { impersonatedClient } from '../../google';

type Body = { title: string; content: string; tags?: string[] };

function tsLabel(d = new Date()) {
  const pad = (n: number) => String(n).padStart(2, '0');
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
}

export async function memorySaveHandler(req: Request, res: Response) {
  try {
    const { title, content, tags } = (req.body || {}) as Partial<Body>;
    if (!title || !content) return res.status(400).json({ ok: false, error: 'Missing title/content' });
    const folderId = process.env.MEMORY_DRIVE_FOLDER_ID || process.env.DRIVE_FOLDER_ID || '';
    if (!folderId) return res.status(500).json({ ok: false, error: 'Missing MEMORY_DRIVE_FOLDER_ID' });

    const safeTitle = String(title).trim().replace(/\s+/g, '-');
    const name = `${tsLabel()}_${safeTitle}.md`;
    const timestamp = new Date().toISOString();
    const tagsLine = (Array.isArray(tags) && tags.length) ? `Tags: ${tags.map(t => `#${String(t).trim().replace(/\s+/g, '-')}`).join(' ')}` : '';
    const md = `# ${title}\n[${timestamp}]\n${tagsLine}\n\n${content}\n`;

    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const stream = Readable.from(Buffer.from(md, 'utf8'));
    const { data } = await drive.files.create({
      requestBody: { name, parents: [folderId] },
      media: { mimeType: 'text/markdown', body: stream },
      fields: 'id,name,webViewLink',
      supportsAllDrives: true,
    } as any);
    (req as any).log?.info?.({ action: 'memory.save', id: (data as any)?.id, name: (data as any)?.name });
    return res.json({ id: (data as any)?.id, name: (data as any)?.name });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'memory.save', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'memory.save failed', details: gerr || undefined });
  }
}

===== src/actions/drive/search.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function searchDriveHandler(req: Request, res: Response) {
  try {
    const query = (req.query.query as string) || (req.body?.query as string) || '';
    const owner = (req.query.owner as string) || (req.body?.owner as string) || '';
    const pageSize = Math.min(parseInt(String(req.query.pageSize || '25'), 10) || 25, 100);
    const pageToken = (req.query.pageToken as string) || undefined;
    if (!query) return res.status(400).json({ ok: false, error: 'Missing query' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive.readonly']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const esc = (s: string) => s.replace(/'/g, "\\'");
    // Basic fuzzy: name contains OR fullText contains
    const qParts = [
      `(name contains '${esc(query)}' or fullText contains '${esc(query)}')`,
      `trashed=false`,
    ];
    const q = qParts.join(' and ');
    const { data } = await drive.files.list({
      q,
      pageSize,
      pageToken,
      fields: 'nextPageToken, files(id,name,mimeType,owners(emailAddress),createdTime,modifiedTime,webViewLink)',
      includeItemsFromAllDrives: true,
      supportsAllDrives: true,
      corpora: 'allDrives',
    } as any);
    let items = (data.files || []).map((f: any) => ({
      id: f.id,
      name: f.name,
      mimeType: f.mimeType,
      owner: f.owners?.[0]?.emailAddress || null,
      createdTime: f.createdTime,
      modifiedTime: f.modifiedTime,
      webViewLink: f.webViewLink,
    }));
    if (owner) items = items.filter(i => (i.owner || '').toLowerCase() === owner.toLowerCase());
    (req as any).log?.info?.({ action: 'drive.search', query, owner: owner || null, count: items.length });
    return res.json({ ok: true, items, nextPageToken: data.nextPageToken || null });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    return res.status(status).json({ ok: false, error: e?.message || 'drive.search failed' });
  }
}

===== src/actions/drive/move.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function moveDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, newParentId } = req.body || {};
    if (!fileId || !newParentId) return res.status(400).json({ ok: false, error: 'Missing fileId/newParentId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const meta = await drive.files.get({ fileId, fields: 'id,parents', supportsAllDrives: true } as any);
    const prevParents = (meta.data.parents || []).join(',');
    const { data } = await drive.files.update({
      fileId,
      addParents: newParentId,
      removeParents: prevParents || undefined,
      fields: 'id,parents',
      supportsAllDrives: true,
    } as any);
    (req as any).log?.info?.({ action: 'drive.move', fileId, newParentId, parents: data.parents });
    return res.json({ ok: true, id: data.id, parents: data.parents });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.move', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.move failed', details: gerr || undefined });
  }
}

===== src/actions/drive/modify.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { Readable } from 'stream';
import { impersonatedClient } from '../../google';

export async function modifyDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, content, mimeType } = req.body || {};
    if (!fileId || typeof content !== 'string') {
      return res.status(400).json({ ok: false, error: 'Missing fileId/content' });
    }
    const mt = (mimeType || '').toString().trim() || 'text/plain';
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, [
      'https://www.googleapis.com/auth/drive.file',
      'https://www.googleapis.com/auth/drive',
    ]);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const stream = Readable.from(Buffer.from(content, 'utf8'));
    const { data } = await drive.files.update({
      fileId,
      media: { mimeType: mt, body: stream },
      fields: 'id,name,modifiedTime',
      supportsAllDrives: true,
    } as any);
    (req as any).log?.info?.({ action: 'drive.modify', fileId, mimeType: mt });
    return res.json({ ok: true, id: data.id, name: (data as any).name, modifiedTime: (data as any).modifiedTime });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.modify', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.modify failed', details: gerr || undefined });
  }
}

===== src/actions/drive/share.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function shareDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, emailAddress, role } = req.body || {};
    const allowed = new Set(['reader', 'writer', 'commenter']);
    if (!fileId || !emailAddress || !allowed.has(String(role))) {
      return res.status(400).json({ ok: false, error: 'fileId, emailAddress, role(reader|writer|commenter) required' });
    }
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    try {
      const result = await drive.permissions.create({
        fileId,
        sendNotificationEmail: false,
        supportsAllDrives: true,
        requestBody: { type: 'user', role, emailAddress },
      } as any);
      (req as any).log?.info?.({ action: 'drive.share', fileId, emailAddress, role, permissionId: result.data.id });
      return res.json({ ok: true, permissionId: result.data.id });
    } catch (err: any) {
      const code = err?.code || err?.response?.status;
      const msg = err?.message || String(err);
      if (code === 404) return res.status(404).json({ ok: false, error: 'file not found' });
      if (code === 409) return res.status(200).json({ ok: true, note: 'already shared or duplicate', error: msg });
      (req as any).log?.warn?.({ action: 'drive.share', fileId, emailAddress, role, error: msg });
      return res.status(code || 500).json({ ok: false, error: msg });
    }
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'drive.share failed' });
  }
}

===== src/actions/drive/duplicate.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function duplicateDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, newName, parentId } = req.body || {};
    if (!fileId) return res.status(400).json({ ok: false, error: 'Missing fileId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const requestBody: any = {};
    if (newName) requestBody.name = String(newName);
    if (parentId) requestBody.parents = [String(parentId)];
    const { data } = await drive.files.copy({ fileId, requestBody, fields: 'id,name,parents,webViewLink', supportsAllDrives: true } as any);
    (req as any).log?.info?.({ action: 'drive.duplicate', fileId, newId: data.id, name: data.name });
    return res.json({ ok: true, id: data.id, name: data.name, parents: (data as any).parents, webViewLink: (data as any).webViewLink });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.duplicate', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.duplicate failed', details: gerr || undefined });
  }
}

===== src/actions/drive/convert.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

const GOOGLE_DOCS = 'application/vnd.google-apps.document';

export async function convertDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, targetMimeType, newName, parentId } = req.body || {};
    if (!fileId || !targetMimeType) return res.status(400).json({ ok: false, error: 'Missing fileId/targetMimeType' });
    const target = String(targetMimeType);
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });

    if (target === 'application/pdf') {
      // Export current file (must be a Google Docs-type) to PDF
      const resp = await drive.files.export({ fileId, mimeType: target }, { responseType: 'arraybuffer' } as any);
      const base64 = Buffer.from(resp.data as any).toString('base64');
      (req as any).log?.info?.({ action: 'drive.convert.export', fileId, target });
      return res.json({ ok: true, fileId, target, contentBase64: base64 });
    }

    if (target.startsWith('application/vnd.google-apps.')) {
      // Convert/import to Google Docs format by copying with target mimeType
      const requestBody: any = { mimeType: target };
      if (newName) requestBody.name = String(newName);
      if (parentId) requestBody.parents = [String(parentId)];
      const { data } = await drive.files.copy({ fileId, requestBody, fields: 'id,name,mimeType,webViewLink', supportsAllDrives: true } as any);
      (req as any).log?.info?.({ action: 'drive.convert.import', fileId, target, newId: data.id });
      return res.json({ ok: true, id: data.id, name: data.name, mimeType: data.mimeType, webViewLink: (data as any)?.webViewLink });
    }

    return res.status(400).json({ ok: false, error: 'Unsupported targetMimeType. Use application/pdf or application/vnd.google-apps.*' });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.convert', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.convert failed', details: gerr || undefined });
  }
}

===== src/actions/drive/rename.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function renameDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, name } = req.body || {};
    if (!fileId || !name) return res.status(400).json({ ok: false, error: 'Missing fileId/name' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const { data } = await drive.files.update({ fileId, requestBody: { name }, fields: 'id,name', supportsAllDrives: true } as any);
    (req as any).log?.info?.({ action: 'drive.rename', fileId, name: data.name });
    return res.json({ ok: true, id: data.id, name: data.name });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.rename', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.rename failed', details: gerr || undefined });
  }
}

===== src/actions/drive/upload.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { Readable } from 'stream';
import { impersonatedClient } from '../../google';

type UploadBody = {
  filename: string;
  mimeType?: string;
  content: string;
  folderId?: string;
};

export async function uploadDriveFileHandler(req: Request, res: Response) {
  try {
    const body = (req.body || {}) as Partial<UploadBody>;
    const filename = (body.filename || '').toString().trim();
    const content = (body.content || '').toString();
    const mimeType = (body.mimeType || 'text/plain').toString();
    const folderId = body.folderId || process.env.MEMORY_DRIVE_FOLDER_ID || process.env.DRIVE_FOLDER_ID || '';
    if (!filename || !content) return res.status(400).json({ ok: false, error: 'Missing filename/content' });
    if (!folderId) return res.status(500).json({ ok: false, error: 'Missing folderId and MEMORY_DRIVE_FOLDER_ID' });

    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });

    const stream = Readable.from(Buffer.from(content, 'utf8'));
    const { data } = await drive.files.create({
      requestBody: { name: filename, parents: [folderId] },
      media: { mimeType, body: stream },
      fields: 'id,name,webViewLink',
      supportsAllDrives: true,
    } as any);

    (req as any).log?.info?.({ action: 'drive.upload', filename, folderId, id: (data as any)?.id });
    return res.json({ id: (data as any)?.id, name: (data as any)?.name, webViewLink: (data as any)?.webViewLink });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.upload', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.upload failed', details: gerr || undefined });
  }
}

===== src/actions/drive/comment.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function commentDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId, content, anchor } = req.body || {};
    if (!fileId || !content) return res.status(400).json({ ok: false, error: 'Missing fileId/content' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const requestBody: any = { content: String(content) };
    if (anchor) requestBody.anchor = String(anchor);
    const { data } = await (drive as any).comments.create({ fileId, requestBody, fields: 'id,content,author/displayName,createdTime' });
    (req as any).log?.info?.({ action: 'drive.comment', fileId, commentId: data.id });
    return res.json({ ok: true, id: data.id, content: data.content, author: (data as any)?.author, createdTime: (data as any)?.createdTime });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.comment', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.comment failed', details: gerr || undefined });
  }
}

===== src/actions/drive/permissions_audit.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function permissionsAuditHandler(req: Request, res: Response) {
  try {
    const fileId = (req.query.fileId as string) || (req.body?.fileId as string) || '';
    if (!fileId) return res.status(400).json({ ok: false, error: 'Missing fileId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const { data } = await drive.permissions.list({ fileId, fields: 'permissions(id,type,role,domain,expirationTime,emailAddress,displayName)', supportsAllDrives: true } as any);
    return res.json({ ok: true, fileId, permissions: data.permissions || [] });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.permissions.audit', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.permissions.audit failed', details: gerr || undefined });
  }
}

===== src/actions/drive/delete.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function deleteDriveFileHandler(req: Request, res: Response) {
  try {
    const { fileId } = req.body || {};
    if (!fileId) return res.status(400).json({ ok: false, error: 'Missing fileId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/drive']);
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    await drive.files.delete({ fileId, supportsAllDrives: true } as any);
    (req as any).log?.info?.({ action: 'drive.delete', fileId });
    return res.json({ ok: true });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'drive.delete', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'drive.delete failed', details: gerr || undefined });
  }
}

===== src/actions/gmail/get.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function getEmailHandler(req: Request, res: Response) {
  try {
    const id = (req.query.id as string) || (req.body?.id as string) || '';
    if (!id) return res.status(400).json({ ok: false, error: 'Missing id' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.readonly']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    const { data } = await gmail.users.messages.get({ userId: 'me', id, format: 'full' });
    (req as any).log?.info?.({ action: 'email.get', id, threadId: data.threadId });
    return res.json({ ok: true, message: data });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'email.get', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'email.get failed', details: gerr || undefined });
  }
}

===== src/actions/gmail/search.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function emailSearchHandler(req: Request, res: Response) {
  try {
    const { query, labelIds, from, to, subject, limit } = (req.method === 'GET' ? req.query : req.body) as any;
    const max = Math.min(parseInt(String(limit || '20'), 10) || 20, 100);
    const terms: string[] = [];
    if (query) terms.push(String(query));
    if (from) terms.push(`from:${from}`);
    if (to) terms.push(`to:${to}`);
    if (subject) terms.push(`subject:${subject}`);
    const q = terms.join(' ').trim() || undefined;
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.readonly']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    const list = await gmail.users.messages.list({ userId: 'me', maxResults: max, q, labelIds: Array.isArray(labelIds) ? labelIds : (labelIds ? [String(labelIds)] : undefined) } as any);
    return res.json({ ok: true, result: list.data });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    return res.status(status).json({ ok: false, error: e?.message || 'email.search failed' });
  }
}

===== src/actions/gmail/star.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function emailStarHandler(req: Request, res: Response) {
  try {
    const { messageId, action } = req.body || {};
    if (!messageId || !action) return res.status(400).json({ ok: false, error: 'Missing messageId/action' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.modify']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    const reqBody: any = { addLabelIds: [], removeLabelIds: [] };
    if (String(action) === 'star') reqBody.addLabelIds = ['STARRED'];
    else if (String(action) === 'unstar') reqBody.removeLabelIds = ['STARRED'];
    else return res.status(400).json({ ok: false, error: 'action must be star|unstar' });
    const { data } = await gmail.users.messages.modify({ userId: 'me', id: String(messageId), requestBody: reqBody });
    return res.json({ ok: true, result: data });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    return res.status(status).json({ ok: false, error: e?.message || 'email.star failed' });
  }
}

===== src/actions/gmail/list.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function listEmailsHandler(req: Request, res: Response) {
  try {
    const label = (req.query.label as string) || (req.query.labelId as string) || 'INBOX';
    const q = (req.query.query as string) || (req.query.q as string) || '';
    const from = (req.query.from as string) || '';
    const maxResults = Math.max(1, Math.min(parseInt(String(req.query.limit || req.query.maxResults || '10'), 10) || 10, 50));
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.readonly']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    let query = q;
    if (from) query = `${query} from:${from}`.trim();
    const list = await gmail.users.messages.list({ userId: 'me', labelIds: [label], maxResults, q: query || undefined });
    const messages = list.data.messages || [];
    const details = await Promise.all(messages.map(async (m) => {
      const g = await gmail.users.messages.get({ userId: 'me', id: m.id!, format: 'metadata', metadataHeaders: ['Subject','From','Date'] });
      const headers = (g.data.payload?.headers || []) as any[];
      const h = (name: string) => headers.find(x => x.name === name)?.value || null;
      return { id: g.data.id, threadId: g.data.threadId, subject: h('Subject'), from: h('From'), date: h('Date'), snippet: g.data.snippet };
    }));
    (req as any).log?.info?.({ action: 'email.list', labelIds: [label], count: details.length });
    return res.json({ ok: true, items: details });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'email.list', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'email.list failed', details: gerr || undefined });
  }
}
===== src/actions/gmail/labels.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function emailLabelsHandler(req: Request, res: Response) {
  try {
    const { mode, labelName, color } = req.body || {};
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.settings.basic']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    if (mode === 'create') {
      if (!labelName) return res.status(400).json({ ok: false, error: 'Missing labelName' });
      const requestBody: any = { name: String(labelName) };
      if (color) requestBody.color = color;
      const { data } = await gmail.users.labels.create({ userId: 'me', requestBody });
      return res.json({ ok: true, label: data });
    }
    // default: list
    const { data } = await gmail.users.labels.list({ userId: 'me' });
    return res.json({ ok: true, labels: data.labels || [] });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    return res.status(status).json({ ok: false, error: e?.message || 'email.labels failed' });
  }
}

===== src/actions/gmail/delete.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function emailDeleteHandler(req: Request, res: Response) {
  try {
    const { messageId, threadId } = req.body || {};
    if (!messageId && !threadId) return res.status(400).json({ ok: false, error: 'Provide messageId or threadId' });
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.modify']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    if (threadId) {
      await gmail.users.threads.delete({ userId: 'me', id: String(threadId) });
      return res.json({ ok: true, deleted: { threadId } });
    }
    await gmail.users.messages.delete({ userId: 'me', id: String(messageId) });
    return res.json({ ok: true, deleted: { messageId } });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    return res.status(status).json({ ok: false, error: e?.message || 'email.delete failed' });
  }
}

===== src/actions/email/draft.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

function toArray(input: string | string[] | undefined): string[] {
  if (!input) return [];
  return (Array.isArray(input) ? input : String(input).split(',')).map(s => s.trim()).filter(Boolean);
}

function buildMime(opts: { from: string; to: string[]; subject: string; text: string; cc?: string[] }) {
  const headers: string[] = [];
  headers.push(`From: ${opts.from}`);
  if (opts.to.length) headers.push(`To: ${opts.to.join(', ')}`);
  if (opts.cc && opts.cc.length) headers.push(`Cc: ${opts.cc.join(', ')}`);
  headers.push(`Subject: ${opts.subject}`);
  headers.push('MIME-Version: 1.0');
  headers.push('Content-Type: text/plain; charset="UTF-8"');
  headers.push('Content-Transfer-Encoding: 7bit');
  const head = headers.join('\r\n');
  return `${head}\r\n\r\n${opts.text}`;
}

export async function saveEmailDraftHandler(req: Request, res: Response) {
  try {
    const { to, subject, text, cc } = req.body || {};
    const toList = toArray(to);
    const ccList = toArray(cc);
    if (!toList.length || !subject || !text) {
      return res.status(400).json({ ok: false, error: 'Missing to/subject/text' });
    }
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const from = process.env.GMAIL_SENDER || user || 'me';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.compose']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    const mime = buildMime({ from, to: toList, subject: String(subject), text: String(text), cc: ccList });
    const raw = Buffer.from(mime).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    const { data } = await gmail.users.drafts.create({ userId: 'me', requestBody: { message: { raw } } });
    (req as any).log?.info?.({ action: 'email.draft', to: toList, subject, id: data.id, messageId: (data.message as any)?.id, threadId: (data.message as any)?.threadId });
    return res.json({ id: data.id, messageId: (data.message as any)?.id, threadId: (data.message as any)?.threadId });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'email.draft', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'email.draft failed', details: gerr || undefined });
  }
}

===== src/actions/email/reply.ts =====
export const replyEmailHandler = () => {}===== src/actions/email/send.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

function toArray(input: string | string[] | undefined): string[] {
  if (!input) return [];
  return (Array.isArray(input) ? input : String(input).split(',')).map(s => s.trim()).filter(Boolean);
}

type Attachment = { filename: string; contentBase64: string; mimeType?: string };

function isValidEmail(e: string) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e);
}

function buildMime(opts: { from: string; to: string[]; subject: string; text: string; cc?: string[], attachments?: Attachment[] }) {
  const headers: string[] = [];
  headers.push(`From: ${opts.from}`);
  if (opts.to.length) headers.push(`To: ${opts.to.join(', ')}`);
  if (opts.cc && opts.cc.length) headers.push(`Cc: ${opts.cc.join(', ')}`);
  headers.push(`Subject: ${opts.subject}`);
  headers.push('MIME-Version: 1.0');

  const atts = opts.attachments || [];
  if (!atts.length) {
    headers.push('Content-Type: text/plain; charset="UTF-8"');
    headers.push('Content-Transfer-Encoding: 7bit');
    const head = headers.join('\r\n');
    return `${head}\r\n\r\n${opts.text}`;
  }
  const boundary = `boundary_${Date.now()}`;
  headers.push(`Content-Type: multipart/mixed; boundary=${boundary}`);
  const head = headers.join('\r\n');
  const parts: string[] = [];
  // text part
  parts.push(`--${boundary}`);
  parts.push('Content-Type: text/plain; charset="UTF-8"');
  parts.push('Content-Transfer-Encoding: 7bit');
  parts.push('');
  parts.push(opts.text);
  // attachments
  for (const a of atts) {
    parts.push(`--${boundary}`);
    parts.push(`Content-Type: ${a.mimeType || 'application/octet-stream'}; name="${a.filename}"`);
    parts.push('Content-Transfer-Encoding: base64');
    parts.push(`Content-Disposition: attachment; filename="${a.filename}"`);
    parts.push('');
    parts.push(a.contentBase64.replace(/\r?\n/g, ''));
  }
  parts.push(`--${boundary}--`);
  return `${head}\r\n\r\n${parts.join('\r\n')}`;
}

export async function sendEmailHandler(req: Request, res: Response) {
  try {
    const { to, subject, text, cc, attachments } = req.body || {};
    const toList = toArray(to);
    const ccList = toArray(cc);
    if (!toList.length || !subject || !text) {
      return res.status(400).json({ ok: false, error: 'Missing to/subject/text' });
    }
    if (toList.some(t => !isValidEmail(t)) || ccList.some(c => !isValidEmail(c))) {
      return res.status(400).json({ ok: false, error: 'Invalid email in to/cc' });
    }
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const from = process.env.GMAIL_SENDER || user || 'me';
    const ic = await impersonatedClient(user, ['https://www.googleapis.com/auth/gmail.send']);
    const gmail = google.gmail({ version: 'v1', auth: ic.auth });
    const mime = buildMime({ from, to: toList, subject: String(subject), text: String(text), cc: ccList, attachments });
    const raw = Buffer.from(mime).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    const { data } = await gmail.users.messages.send({ userId: 'me', requestBody: { raw } });
    (req as any).log?.info?.({ action: 'email.send', to: toList, subject, id: data.id, threadId: data.threadId });
    return res.json({ id: data.id, threadId: data.threadId, labelIds: data.labelIds });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'email.send', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'email.send failed', details: gerr || undefined });
  }
}
===== src/actions/debug/whoami.ts =====
import { Request, Response } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../../google';

export async function actionsWhoamiHandler(req: Request, res: Response) {
  try {
    const user = process.env.IMPERSONATE_USER || process.env.GMAIL_SENDER || '';
    const ic = await impersonatedClient(user, [
      'https://www.googleapis.com/auth/userinfo.email',
      'https://www.googleapis.com/auth/drive.readonly',
    ]);
    const oauth2 = google.oauth2({ version: 'v2', auth: ic.auth as any });
    const drive = google.drive({ version: 'v3', auth: ic.auth });
    const [uinfo, about] = await Promise.all([
      oauth2.userinfo.get({} as any),
      drive.about.get({ fields: 'user,permissionId', supportsAllDrives: true } as any),
    ]);
    const email = (uinfo.data as any)?.email || null;
    const userId = (uinfo.data as any)?.id || null;
    const drivePermissionId = (about.data as any)?.permissionId || (about.data as any)?.user?.permissionId || null;
    const domain = email ? String(email).split('@')[1] : null;
    const env = {
      PROJECT: process.env.GCP_PROJECT_ID || process.env.GOOGLE_CLOUD_PROJECT || null,
      IMPERSONATE_USER: !!process.env.IMPERSONATE_USER,
      GMAIL_SENDER: !!process.env.GMAIL_SENDER,
      MEMORY_DRIVE_FOLDER_ID: !!process.env.MEMORY_DRIVE_FOLDER_ID,
      BALI_ZERO_CALENDAR_ID: !!process.env.BALI_ZERO_CALENDAR_ID,
    };
    (req as any).log?.info?.({ action: 'actions.debug.whoami', email, userId, drivePermissionId, domain });
    return res.json({ email, userId, drivePermissionId, domain, env });
  } catch (e: any) {
    const status = e?.response?.status || 500;
    const gerr = e?.response?.data || null;
    (req as any).log?.error?.({ action: 'actions.debug.whoami', error: e?.message || String(e), status, gerr });
    return res.status(status).json({ ok: false, error: e?.message || 'whoami failed', details: gerr || undefined });
  }
}

===== src/lib/googleApiHelpers.ts =====
import { google } from 'googleapis';

// =============================
// GOOGLE DRIVE
// =============================

export async function driveModifyFile(fileId: string, content: string, auth: any, mimeType = 'text/plain') {
  const drive = google.drive({ version: 'v3', auth });
  const res = await drive.files.update({
    fileId,
    media: {
      mimeType,
      body: content,
    },
    fields: 'id,name,modifiedTime',
    supportsAllDrives: true,
  } as any);
  return res.data;
}

export async function driveShare(fileId: string, email: string, role: 'reader' | 'writer' | 'commenter', auth: any) {
  const drive = google.drive({ version: 'v3', auth });
  const res = await drive.permissions.create({
    fileId,
    requestBody: {
      role,
      type: 'user',
      emailAddress: email,
    },
    sendNotificationEmail: false,
    supportsAllDrives: true,
  } as any);
  return res.data;
}

export async function driveSearch(query: string, auth: any) {
  const drive = google.drive({ version: 'v3', auth });
  const res = await drive.files.list({
    q: query,
    fields: 'files(id,name,mimeType,webViewLink)',
    includeItemsFromAllDrives: true,
    supportsAllDrives: true,
    corpora: 'allDrives',
  } as any);
  return res.data.files || [];
}

export async function driveRename(fileId: string, newName: string, auth: any) {
  const drive = google.drive({ version: 'v3', auth });
  const res = await drive.files.update({
    fileId,
    requestBody: { name: newName },
    fields: 'id,name',
    supportsAllDrives: true,
  } as any);
  return res.data;
}

// =============================
// GOOGLE CALENDAR
// =============================

export async function calendarList(auth: any, calendarId: string = 'primary', maxResults = 10) {
  const calendar = google.calendar({ version: 'v3', auth });
  const res = await calendar.events.list({
    calendarId,
    timeMin: new Date().toISOString(),
    singleEvents: true,
    orderBy: 'startTime',
    maxResults,
  } as any);
  return res.data.items || [];
}

export async function calendarGet(eventId: string, calendarId: string, auth: any) {
  const calendar = google.calendar({ version: 'v3', auth });
  const res = await calendar.events.get({ calendarId, eventId } as any);
  return res.data;
}

export async function calendarQuickAdd(text: string, calendarId: string, auth: any) {
  const calendar = google.calendar({ version: 'v3', auth });
  const res = await calendar.events.quickAdd({ calendarId, text } as any);
  return res.data;
}

export async function calendarCancel(eventId: string, calendarId: string, auth: any) {
  const calendar = google.calendar({ version: 'v3', auth });
  await calendar.events.delete({ calendarId, eventId } as any);
  return { success: true } as const;
}

// =============================
// GMAIL
// =============================

function toBase64Url(input: string) {
  return Buffer.from(input)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
}

export async function gmailDraft(to: string, subject: string, body: string, auth: any) {
  const gmail = google.gmail({ version: 'v1', auth });
  const rawMime = `To: ${to}\r\nSubject: ${subject}\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=\"UTF-8\"\r\nContent-Transfer-Encoding: 7bit\r\n\r\n${body}`;
  const raw = toBase64Url(rawMime);
  const res = await gmail.users.drafts.create({
    userId: 'me',
    requestBody: { message: { raw } },
  });
  return res.data;
}

export async function gmailSend(to: string, subject: string, body: string, auth: any) {
  const gmail = google.gmail({ version: 'v1', auth });
  const rawMime = `To: ${to}\r\nSubject: ${subject}\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=\"UTF-8\"\r\nContent-Transfer-Encoding: 7bit\r\n\r\n${body}`;
  const raw = toBase64Url(rawMime);
  const res = await gmail.users.messages.send({
    userId: 'me',
    requestBody: { raw },
  });
  return res.data;
}

export async function gmailRead(query: string, auth: any) {
  const gmail = google.gmail({ version: 'v1', auth });
  const res = await gmail.users.messages.list({ userId: 'me', q: query });
  return res.data.messages || [];
}

export async function gmailReply(messageId: string, body: string, auth: any) {
  const gmail = google.gmail({ version: 'v1', auth });
  // Fetch original to get threadId and headers
  const original = await gmail.users.messages.get({ userId: 'me', id: messageId, format: 'metadata', metadataHeaders: ['Subject', 'Message-ID', 'References', 'From', 'To'] });
  const headers = (original.data.payload?.headers || []) as any[];
  const h = (name: string) => headers.find(x => x.name === name)?.value || '';
  const subject = h('Subject')?.startsWith('Re:') ? h('Subject') : `Re: ${h('Subject')}`.trim();
  const inReplyTo = h('Message-ID');
  const references = h('References');
  const to = h('From') || 'me';
  const rawMime = [
    `To: ${to}`,
    `Subject: ${subject}`,
    inReplyTo ? `In-Reply-To: ${inReplyTo}` : '',
    references ? `References: ${references} ${inReplyTo}`.trim() : (inReplyTo ? `References: ${inReplyTo}` : ''),
    'MIME-Version: 1.0',
    'Content-Type: text/plain; charset="UTF-8"',
    'Content-Transfer-Encoding: 7bit',
    '',
    body,
  ].filter(Boolean).join('\r\n');
  const raw = toBase64Url(rawMime);
  const res = await gmail.users.messages.send({ userId: 'me', requestBody: { raw, threadId: original.data.threadId! } });
  return res.data;
}

// =============================
// PREVENT ZANTARA OVERREACH
// =============================

export function qualifyResponse(content: string, sourceConfidence: 'high' | 'low' | string) {
  if (sourceConfidence === 'high') {
    return `Zantara afferma: ${content}`;
  } else {
    return `Zantara ritiene: ${content}`;
  }
}

// =============================
// DISABLE EXTERNAL PROMPT REQUESTS
// =============================

export function validateAPIAccess(requestSource: string) {
  if (requestSource === 'external-prompt') {
    throw new Error('Richieste di approvazione esterne disabilitate per motivi di sicurezza.');
  }
  return true;
}

===== src/api/drive.ts =====
import { Request, Response, Express } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../google';

function logDriveAction(action: string, details: any) {
  console.log(`[DRIVE] ${action}`, JSON.stringify(details));
}

export const driveRoutes = (app: Express) => {
  // Crea file Google Doc in una cartella
  app.post('/actions/drive/create', async (req: Request, res: Response) => {
import { Request, Response, NextFunction, Express } from 'express';
import { google } from 'googleapis';
import { impersonatedClient } from '../google';
...
    try {
      const name = (req.body?.name as string) || 'SmokeTest Zantara';
      const parent = process.env.DRIVE_FOLDER_ID;
      if (!parent) return res.status(500).json({ ok: false, error: 'Missing DRIVE_FOLDER_ID' });
      const user = process.env.IMPERSONATE_USER || '';
      const ic = await impersonatedClient(user, [
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive',
      ]);
      const drive = google.drive({ version: 'v3', auth: ic.auth });
      const { data } = await drive.files.create({
        requestBody: { name, mimeType: 'application/vnd.google-apps.document', parents: [parent] },
        fields: 'id,webViewLink,parents',
        supportsAllDrives: true,
      });
      logDriveAction('create.success', { name, id: data.id, parent: parent, link: data.webViewLink });
      res.json({ ok: true, action: 'drive.create', fileId: data.id, webViewLink: data.webViewLink, parentId: parent });
    } catch (e: any) {
      logDriveAction('create.error', { error: e.message });
      res.status(500).json({ ok: false, error: e.message });
    }
  });

  // (Altri endpoint Drive qui...)
};
===== src/api/identity.ts =====
import { Router, Request, Response } from "express";

const router = Router();

// In memoria: identità corrente
let currentUser: { name: string; email?: string; role?: string } | null = null;

// Parola magica letta da env
const MAGIC = process.env.AMBARADAM_MAGIC_WORD || "BaliZero2025";

// POST /identity/login
router.post("/identity/login", (req: Request, res: Response) => {
  const { name, magicWord } = req.body || {};
  if (!name || !magicWord) {
    return res.status(400).json({ ok: false, error: "missing_name_or_word" });
  }
  if (magicWord !== MAGIC) {
    return res.status(401).json({ ok: false, error: "unauthorized" });
  }
  currentUser = { name: String(name) };
  return res.json({ ok: true, userId: currentUser.name });
});

// GET /identity/me
router.get("/identity/me", (req: Request, res: Response) => {
  if (currentUser) {
    return res.json({
      ok: true,
      data: {
        name: currentUser.name,
        email: currentUser.email || null,
        role: currentUser.role || "user",
        defaults: {
          folderId: process.env.MEMORY_DRIVE_FOLDER_ID || null,
          calendarId: process.env.BALI_ZERO_CALENDAR_ID || null,
        },
      },
    });
  }
  const email = (req.header("x-user-email") || req.query.email || "").toString();
  const role = email === "zero@balizero.com" ? "boss" : "user";
  return res.json({
    ok: true,
    data: {
      email,
      role,
      defaults: {
        folderId: process.env.MEMORY_DRIVE_FOLDER_ID || null,
        calendarId: process.env.BALI_ZERO_CALENDAR_ID || null,
      },
    },
  });
});

// Middleware: blocca se non loggato
export function requireIdentity(req: Request, res: Response, next: Function) {
  if (!currentUser) {
    return res.status(401).json({ ok: false, error: "AMBARADAM authentication required" });
  }
  next();
}

export default router;
===== src/api/gmail.ts =====
export default {}===== src/api/chat.ts =====
import express from 'express';

const router = express.Router();

// NOTE: delete/forget endpoint intentionally removed.
// Deletion of recaps is forbidden via API. For legal/HR deletion requests use out-of-band manual process.

export default router;
===== src/api/calendar.ts =====
import { Router } from "express";
const r = Router();
r.get("/actions/calendar/health", (_req, res) => res.status(200).json({ ok: true, service: "calendar" }));
r.post("/actions/calendar/echo", (req, res) => res.status(200).json({ ok: true, input: req.body ?? null }));
export default r;
===== src/api/openapi.ts =====
import { Router } from 'express';
const r = Router();
const yaml = `openapi: 3.0.0\ninfo:\n  title: Zantara API\n  version: 1.0.0\npaths:\n  /health:\n    get:\n      summary: Health\n      responses:\n        "200":\n          description: OK\n`;
r.get('/.well-known/openapi.yaml', (_req,res)=>res.type('text/yaml').send(yaml));
export default r;
===== src/api/memory.ts =====
export default {}===== src/api/codex.ts =====
import { Router, Request, Response } from 'express';
import { requireApiKey } from '../middleware/auth';
const router = Router();
router.use(requireApiKey as any);

router.post('/dispatch', (req: Request, res: Response) => {
  const { event_type, payload } = req.body || {};
  return res.status(202).json({ ok: true, data: { request_id: 'rq_stub', status: 'queued', event_type, payload } });
});

router.get('/status/:request_id', (req: Request, res: Response) => {
  const { request_id } = req.params;
  return res.json({ ok: true, data: { request_id, status: 'done', output: { note: 'stub' } } });
});

export default { prefix: '/actions/codex', router };
===== src/api/tasks.ts =====
export default {}===== src/test_calendar.integration.ts =====
import request = require('supertest');
import express = require('express');
import { calendarRoutes } from './api/calendar';

describe('Calendar integration (real Google Calendar)', () => {
  let app: express.Express;
  let createdEventId: string | null = null;
  const calendarId = process.env.BALI_ZERO_CALENDAR_ID || 'primary';
  beforeAll(() => {
    app = express();
    app.use(express.json());
    calendarRoutes(app);
  });

  it('should create an event', async () => {
    const res = await request(app)
      .post('/actions/calendar/create')
      .send({ calendarId, summary: 'Test Event', attendees: [] });
    expect(res.status).toBe(200);
    expect(res.body.ok).toBe(true);
    expect(res.body.eventId).toBeDefined();
    createdEventId = res.body.eventId;
  });

  it('should update the event', async () => {
    if (!createdEventId) return;
    const res = await request(app)
      .post('/actions/calendar/update')
      .send({ calendarId, eventId: createdEventId, updates: { summary: 'Updated Event' } });
    expect(res.status).toBe(200);
    expect(res.body.ok).toBe(true);
    expect(res.body.event.id).toBe(createdEventId);
    expect(res.body.event.summary).toBe('Updated Event');
  });

  it('should get the event', async () => {
    if (!createdEventId) return;
    const res = await request(app)
      .get('/actions/calendar/get')
      .query({ calendarId, eventId: createdEventId });
    expect(res.status).toBe(200);
    expect(res.body.ok).toBe(true);
    expect(res.body.event.id).toBe(createdEventId);
  });

  it('should delete the event', async () => {
    if (!createdEventId) return;
    const res = await request(app)
      .post('/actions/calendar/delete')
      .send({ calendarId, eventId: createdEventId });
    expect(res.status).toBe(200);
    expect(res.body.ok).toBe(true);
  });
});
===== src/server.ts =====
import express from "express";
import router from "./chatRouter";
import identity, { requireIdentity } from "./api/identity";
import gmail from "./api/gmail";
import memory from "./api/memory";

const app = express();
app.use(express.json());

// Rotte principali (Codex, Drive, Calendar…)
app.use(router);

// Health check
app.get("/health", (_req, res) => res.json({ ok: true, service: "zantara-bridge" }));

// Identity (login/me)
app.use(identity);

// Azioni che richiedono login AMBARADAM
app.use("/actions/gmail", requireIdentity, gmail);
app.use("/actions/memory", requireIdentity, memory);

// Porta
const port = process.env.PORT || 8080;
app.listen(port, () => console.log("Listening on", port));

export default app;
===== src/routes/actions/codex/dispatch.ts =====
import { defineEventHandler, readBody } from 'h3';
import { $fetch } from 'ofetch';
import { randomUUID } from 'crypto';

const REQUIRED_TOKEN = process.env.CODEX_DISPATCH_TOKEN;

export default defineEventHandler(async (event) => {
  const auth = event.headers.get('authorization') || '';
  const token = auth.replace('Bearer ', '').trim();

  console.log('🔐 Received token:', token);
  console.log('✅ Expected token:', REQUIRED_TOKEN);

  if (!REQUIRED_TOKEN || token !== REQUIRED_TOKEN) {
    return { ok: false, error: 'Unauthorized' };
  }

  const payload = await readBody(event);
  const requestId = randomUUID();
  const branch = `codex/update-${requestId}`;

  const body = {
    event_type: 'codex-apply-patch',
    client_payload: {
      branch,
      title: payload.title,
      body: `${payload.body}\n\nZANTARA req: ${requestId}`,
      patch_b64: payload.patch_b64,
      requestId,
    },
  };

  console.log('🚀 Dispatching to GitHub:', body);

  const res = await $fetch(`https://api.github.com/repos/Balizero1987/zantara_bridge/dispatches`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${REQUIRED_TOKEN}`,
      Accept: 'application/vnd.github+json',
      'Content-Type': 'application/json',
    },
    body,
  }).catch(async (err) => {
    const msg = await err.response?.text();
    console.error('❌ Dispatch error:', msg);
    throw new Error('GitHub dispatch failed');
  });

  return {
    ok: true,
    status: res.status,
    requestId,
    branch,
  };
});
===== package.json =====
{
  "name": "zantara-bridge",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "lint": "eslint . --ext .ts,.js"
  },
  "dependencies": {
    "@google-cloud/firestore": "^7.11.3",
    "@google-cloud/secret-manager": "^6.1.0",
    "bullmq": "^2.4.0",
    "cors": "^2.8.5",
    "docx": "^9.5.1",
    "dotenv": "^16.1.4",
    "express": "^4.18.2",
    "googleapis": "^159.0.0",
    "h3": "^1.15.4",
    "ioredis": "^5.3.2",
    "node-fetch": "^2.6.7",
    "ofetch": "^1.4.1",
    "on-finished": "^2.4.1",
    "openai": "^5.19.1",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^4.17.21",
    "@types/node": "^20.5.1",
    "@types/on-finished": "^2.3.5",
    "@types/uuid": "^10.0.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.2.2"
  }
}
===== tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["src/test*", "**/*.test.ts"]
}
===== Dockerfile =====
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json tsconfig.json ./
RUN npm ci
COPY src ./src
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY --from=builder /app/dist ./dist
EXPOSE 8080
CMD ["node","dist/server.js"]
===== .gitignore =====
# Node / TypeScript
node_modules/
**/node_modules/
dist/
build/
coverage/
*.log
*.tsbuildinfo

# Local OS/editor
.DS_Store
Thumbs.db
.idea/
.vscode/*
!.vscode/extensions.json

# Env/keys
.env
.env.*
openai.key
service-account.json
zantara-key.json

# Artifacts / bundles / exports
*.tgz
*.bundle
post_deploy_results.txt

# Accidental folders
zantara-chat 2/
zantara-chat 2/node_modules/

# GitHub / workflows scratch copies
.github/workflows/* 2.yml
.github/workflows/deploy-cloudrun
.github/workflows/deploy-cloudrun-manual 2.yml

# codex tmp
CODEX_TEST
codex.patch
payload.json
t.patchwc
*.save
setup_codex_dispatch.sh^*

node_modules
dist
.DS_Store
